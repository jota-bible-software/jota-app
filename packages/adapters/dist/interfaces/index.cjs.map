{"version":3,"sources":["../../src/interfaces/storage.ts","../../src/interfaces/network.ts","../../src/interfaces/audio.ts","../../src/interfaces/platform.ts"],"names":[],"mappings":";;;AAiIO,IAAM,YAAA,GAAN,cAA2B,KAAA,CAAM;AAAA,EACtC,WAAA,CACE,SACgB,IAAA,EAChB;AACA,IAAA,KAAA,CAAM,OAAO,CAAA;AAFG,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AAGhB,IAAA,IAAA,CAAK,IAAA,GAAO,cAAA;AAAA,EACd;AACF;;;ACsCO,IAAM,YAAA,GAAN,cAA2B,KAAA,CAAM;AAAA,EACtC,WAAA,CACE,OAAA,EACgB,IAAA,EACA,MAAA,EACA,QAAA,EAChB;AACA,IAAA,KAAA,CAAM,OAAO,CAAA;AAJG,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AACA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,IAAA,CAAA,QAAA,GAAA,QAAA;AAGhB,IAAA,IAAA,CAAK,IAAA,GAAO,cAAA;AAAA,EACd;AACF;;;ACmCO,IAAM,UAAA,GAAN,cAAyB,KAAA,CAAM;AAAA,EACpC,WAAA,CACE,SACgB,IAAA,EAChB;AACA,IAAA,KAAA,CAAM,OAAO,CAAA;AAFG,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AAGhB,IAAA,IAAA,CAAK,IAAA,GAAO,YAAA;AAAA,EACd;AACF;;;ACoHO,IAAM,aAAA,GAAN,cAA4B,KAAA,CAAM;AAAA,EACvC,WAAA,CACE,SACgB,IAAA,EAChB;AACA,IAAA,KAAA,CAAM,OAAO,CAAA;AAFG,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AAGhB,IAAA,IAAA,CAAK,IAAA,GAAO,eAAA;AAAA,EACd;AACF","file":"index.cjs","sourcesContent":["/**\n * Storage adapter interface\n * Platform-agnostic storage abstraction with support for\n * key-value storage, structured data, and batch operations\n */\n\n/**\n * Storage change event\n */\nexport interface StorageChangeEvent<T = unknown> {\n  key: string\n  oldValue: T | null\n  newValue: T | null\n}\n\n/**\n * Comprehensive storage adapter interface\n * Supports both simple key-value and structured collection-based storage\n */\nexport interface IStorageAdapter {\n  // Key-value storage\n  /**\n   * Get a value from storage\n   * @param key - Storage key\n   * @returns Stored value or null if not found\n   */\n  get<T>(key: string): Promise<T | null>\n\n  /**\n   * Set a value in storage\n   * @param key - Storage key\n   * @param value - Value to store\n   */\n  set<T>(key: string, value: T): Promise<void>\n\n  /**\n   * Delete a value from storage\n   * @param key - Storage key\n   */\n  delete(key: string): Promise<void>\n\n  /**\n   * Clear all stored values\n   */\n  clear(): Promise<void>\n\n  /**\n   * Get all storage keys\n   */\n  keys(): Promise<string[]>\n\n  // Structured storage for large/organized data\n  /**\n   * Get a structured item from a collection\n   * @param collection - Collection name\n   * @param id - Item identifier\n   */\n  getStructured<T>(collection: string, id: string): Promise<T | null>\n\n  /**\n   * Set a structured item in a collection\n   * @param collection - Collection name\n   * @param id - Item identifier\n   * @param value - Value to store\n   */\n  setStructured<T>(collection: string, id: string, value: T): Promise<void>\n\n  /**\n   * Delete structured item(s) from a collection\n   * @param collection - Collection name\n   * @param id - Optional item identifier (deletes entire collection if omitted)\n   */\n  deleteStructured(collection: string, id?: string): Promise<void>\n\n  /**\n   * List all item IDs in a collection\n   * @param collection - Collection name\n   */\n  listStructured(collection: string): Promise<string[]>\n\n  // Bulk operations\n  /**\n   * Get multiple values at once\n   * @param keys - Array of storage keys\n   */\n  getBatch<T>(keys: string[]): Promise<Record<string, T | null>>\n\n  /**\n   * Set multiple values at once\n   * @param data - Key-value pairs to store\n   */\n  setBatch(data: Record<string, unknown>): Promise<void>\n\n  // Events\n  /**\n   * Subscribe to storage changes\n   * @param callback - Called when storage changes\n   * @returns Cleanup function to unsubscribe\n   */\n  onChanged<T>(callback: (event: StorageChangeEvent<T>) => void): () => void\n}\n\n/**\n * Synchronous storage adapter for simple use cases\n * Useful when async is not needed (e.g., localStorage)\n */\nexport interface ISyncStorageAdapter {\n  get<T>(key: string): T | null\n  set<T>(key: string, value: T): void\n  delete(key: string): void\n  clear(): void\n  keys(): string[]\n  has(key: string): boolean\n}\n\n/**\n * Storage error codes\n */\nexport type StorageErrorCode =\n  | 'QUOTA_EXCEEDED'\n  | 'NOT_AVAILABLE'\n  | 'PERMISSION_DENIED'\n  | 'NOT_FOUND'\n  | 'INVALID_DATA'\n  | 'UNKNOWN'\n\n/**\n * Storage error class\n */\nexport class StorageError extends Error {\n  constructor(\n    message: string,\n    public readonly code: StorageErrorCode\n  ) {\n    super(message)\n    this.name = 'StorageError'\n  }\n}\n\n/**\n * Storage adapter configuration\n */\nexport interface StorageAdapterConfig {\n  /** Prefix for all storage keys */\n  prefix?: string\n  /** Maximum storage quota in bytes (if supported) */\n  maxQuota?: number\n  /** Enable compression for large values */\n  compression?: boolean\n}\n","/**\n * Network adapter interface\n * Platform-agnostic network abstraction for HTTP requests,\n * file downloads, caching, and connection status\n */\n\n/**\n * HTTP request options\n */\nexport interface RequestOptions {\n  /** Request headers */\n  headers?: Record<string, string>\n  /** Request timeout in milliseconds */\n  timeout?: number\n  /** Abort signal for request cancellation */\n  signal?: AbortSignal\n  /** Enable/disable credentials (cookies) */\n  credentials?: 'include' | 'omit' | 'same-origin'\n  /** Response type */\n  responseType?: 'json' | 'text' | 'blob' | 'arraybuffer'\n}\n\n/**\n * HTTP response wrapper\n */\nexport interface HttpResponse<T> {\n  /** Response data */\n  data: T\n  /** HTTP status code */\n  status: number\n  /** Response headers */\n  headers: Record<string, string>\n  /** Whether the request was successful (2xx status) */\n  ok: boolean\n}\n\n/**\n * Download progress information\n */\nexport interface DownloadProgress {\n  /** Bytes loaded */\n  loaded: number\n  /** Total bytes (if known) */\n  total: number | null\n  /** Progress percentage (0-100) */\n  percent: number\n}\n\n/**\n * Cache entry metadata\n */\nexport interface CacheEntry<T> {\n  /** Cached data */\n  data: T\n  /** When the entry was cached (timestamp) */\n  cachedAt: number\n  /** Time-to-live in milliseconds */\n  ttl: number\n}\n\n/**\n * Network adapter interface\n */\nexport interface INetworkAdapter {\n  // HTTP requests\n  /**\n   * Perform a GET request\n   * @param url - Request URL\n   * @param options - Request options\n   */\n  get<T>(url: string, options?: RequestOptions): Promise<HttpResponse<T>>\n\n  /**\n   * Perform a POST request\n   * @param url - Request URL\n   * @param data - Request body\n   * @param options - Request options\n   */\n  post<T>(url: string, data: unknown, options?: RequestOptions): Promise<HttpResponse<T>>\n\n  /**\n   * Perform a PUT request\n   * @param url - Request URL\n   * @param data - Request body\n   * @param options - Request options\n   */\n  put<T>(url: string, data: unknown, options?: RequestOptions): Promise<HttpResponse<T>>\n\n  /**\n   * Perform a PATCH request\n   * @param url - Request URL\n   * @param data - Request body\n   * @param options - Request options\n   */\n  patch<T>(url: string, data: unknown, options?: RequestOptions): Promise<HttpResponse<T>>\n\n  /**\n   * Perform a DELETE request\n   * @param url - Request URL\n   * @param options - Request options\n   */\n  delete<T>(url: string, options?: RequestOptions): Promise<HttpResponse<T>>\n\n  // File downloads\n  /**\n   * Download a file as Blob\n   * @param url - File URL\n   * @param onProgress - Progress callback\n   */\n  downloadFile(url: string, onProgress?: (progress: DownloadProgress) => void): Promise<Blob>\n\n  /**\n   * Download and parse JSON\n   * @param url - JSON URL\n   * @param onProgress - Progress callback\n   */\n  downloadJson<T>(url: string, onProgress?: (progress: DownloadProgress) => void): Promise<T>\n\n  // Caching\n  /**\n   * Get cached data if still valid\n   * @param url - Cache key (usually the URL)\n   * @param maxAge - Maximum age in milliseconds\n   */\n  getCached<T>(url: string, maxAge?: number): Promise<T | null>\n\n  /**\n   * Store data in cache\n   * @param url - Cache key\n   * @param data - Data to cache\n   * @param ttl - Time-to-live in milliseconds\n   */\n  setCached<T>(url: string, data: T, ttl?: number): Promise<void>\n\n  /**\n   * Invalidate cached data\n   * @param url - Cache key to invalidate\n   */\n  invalidateCache(url: string): Promise<void>\n\n  /**\n   * Clear all cached data\n   */\n  clearCache(): Promise<void>\n\n  // Connection status\n  /**\n   * Check if currently online\n   */\n  isOnline(): Promise<boolean>\n\n  /**\n   * Subscribe to connection status changes\n   * @param callback - Called when connection status changes\n   * @returns Cleanup function\n   */\n  onConnectionChange(callback: (online: boolean) => void): () => void\n}\n\n/**\n * Network error codes\n */\nexport type NetworkErrorCode =\n  | 'TIMEOUT'\n  | 'OFFLINE'\n  | 'ABORTED'\n  | 'NOT_FOUND'\n  | 'SERVER_ERROR'\n  | 'NETWORK_ERROR'\n  | 'PARSE_ERROR'\n  | 'UNKNOWN'\n\n/**\n * Network error class\n */\nexport class NetworkError extends Error {\n  constructor(\n    message: string,\n    public readonly code: NetworkErrorCode,\n    public readonly status?: number,\n    public readonly response?: unknown\n  ) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n\n/**\n * Network adapter configuration\n */\nexport interface NetworkAdapterConfig {\n  /** Base URL for all requests */\n  baseUrl?: string\n  /** Default timeout in milliseconds */\n  timeout?: number\n  /** Default headers for all requests */\n  headers?: Record<string, string>\n  /** Enable request/response logging */\n  debug?: boolean\n  /** Retry configuration */\n  retry?: {\n    /** Maximum retry attempts */\n    maxAttempts: number\n    /** Delay between retries in milliseconds */\n    delay: number\n    /** Multiply delay by this factor for each retry */\n    backoffFactor?: number\n  }\n}\n","/**\n * Audio adapter interface\n * Platform-agnostic audio playback abstraction\n */\n\n/**\n * Audio playback state\n */\nexport type AudioState = 'idle' | 'loading' | 'playing' | 'paused' | 'ended' | 'error'\n\n/**\n * Audio playback options\n */\nexport interface AudioOptions {\n  /** Initial volume (0-1) */\n  volume?: number\n  /** Playback rate (0.5-2.0 typically) */\n  playbackRate?: number\n  /** Start position in seconds */\n  startTime?: number\n  /** Whether to loop playback */\n  loop?: boolean\n  /** Preload strategy */\n  preload?: 'none' | 'metadata' | 'auto'\n}\n\n/**\n * Audio handle returned by play()\n * Used to control an active audio instance\n */\nexport interface IAudioHandle {\n  /** Unique identifier for this playback instance */\n  id: string\n  /** Source URL */\n  url: string\n  /** Current playback state */\n  state: AudioState\n}\n\n/**\n * Audio playback event data\n */\nexport interface AudioEvent {\n  /** Event type */\n  type: 'statechange' | 'timeupdate' | 'ended' | 'error' | 'loaded'\n  /** Audio handle */\n  handle: IAudioHandle\n  /** Current playback time in seconds */\n  currentTime?: number\n  /** Total duration in seconds */\n  duration?: number\n  /** Error message (if type is 'error') */\n  error?: string\n}\n\n/**\n * Audio event callback\n */\nexport type AudioEventCallback = (event: AudioEvent) => void\n\n/**\n * Audio metadata\n */\nexport interface AudioMetadata {\n  /** Duration in seconds */\n  duration: number\n  /** Sample rate in Hz */\n  sampleRate?: number\n  /** Number of audio channels */\n  channels?: number\n  /** File format */\n  format?: string\n}\n\n/**\n * Audio adapter interface\n */\nexport interface IAudioAdapter {\n  // Playback control\n  /**\n   * Start playing audio from a URL\n   * @param url - Audio source URL\n   * @param options - Playback options\n   * @returns Audio handle for controlling playback\n   */\n  play(url: string, options?: AudioOptions): Promise<IAudioHandle>\n\n  /**\n   * Pause playback\n   * @param handle - Audio handle from play()\n   */\n  pause(handle: IAudioHandle): Promise<void>\n\n  /**\n   * Resume paused playback\n   * @param handle - Audio handle from play()\n   */\n  resume(handle: IAudioHandle): Promise<void>\n\n  /**\n   * Stop playback and release resources\n   * @param handle - Audio handle from play()\n   */\n  stop(handle: IAudioHandle): Promise<void>\n\n  // Seek and position\n  /**\n   * Get current playback position\n   * @param handle - Audio handle\n   * @returns Current time in seconds\n   */\n  getCurrentTime(handle: IAudioHandle): Promise<number>\n\n  /**\n   * Seek to a position\n   * @param handle - Audio handle\n   * @param time - Position in seconds\n   */\n  setCurrentTime(handle: IAudioHandle, time: number): Promise<void>\n\n  /**\n   * Get audio duration\n   * @param handle - Audio handle or URL\n   * @returns Duration in seconds\n   */\n  getDuration(handle: IAudioHandle | string): Promise<number>\n\n  // Volume control\n  /**\n   * Get current volume\n   * @param handle - Audio handle\n   * @returns Volume (0-1)\n   */\n  getVolume(handle: IAudioHandle): Promise<number>\n\n  /**\n   * Set volume\n   * @param handle - Audio handle\n   * @param volume - Volume (0-1)\n   */\n  setVolume(handle: IAudioHandle, volume: number): Promise<void>\n\n  /**\n   * Mute audio\n   * @param handle - Audio handle\n   */\n  mute(handle: IAudioHandle): Promise<void>\n\n  /**\n   * Unmute audio\n   * @param handle - Audio handle\n   */\n  unmute(handle: IAudioHandle): Promise<void>\n\n  // Playback rate\n  /**\n   * Get current playback rate\n   * @param handle - Audio handle\n   * @returns Playback rate (1.0 = normal)\n   */\n  getPlaybackRate(handle: IAudioHandle): Promise<number>\n\n  /**\n   * Set playback rate\n   * @param handle - Audio handle\n   * @param rate - Playback rate (0.5-2.0 typically)\n   */\n  setPlaybackRate(handle: IAudioHandle, rate: number): Promise<void>\n\n  // Metadata\n  /**\n   * Get audio metadata\n   * @param url - Audio URL\n   */\n  getMetadata(url: string): Promise<AudioMetadata>\n\n  // Preloading\n  /**\n   * Preload audio for faster playback\n   * @param url - Audio URL\n   */\n  preload(url: string): Promise<void>\n\n  /**\n   * Cancel preloading\n   * @param url - Audio URL\n   */\n  cancelPreload(url: string): Promise<void>\n\n  // Events\n  /**\n   * Subscribe to playback events\n   * @param handle - Audio handle\n   * @param callback - Event callback\n   * @returns Cleanup function\n   */\n  onPlaybackChange(handle: IAudioHandle, callback: AudioEventCallback): () => void\n\n  // Cleanup\n  /**\n   * Stop all playback and release all resources\n   */\n  dispose(): Promise<void>\n}\n\n/**\n * Audio error codes\n */\nexport type AudioErrorCode =\n  | 'NOT_SUPPORTED'\n  | 'NETWORK_ERROR'\n  | 'DECODE_ERROR'\n  | 'PERMISSION_DENIED'\n  | 'NOT_FOUND'\n  | 'ABORTED'\n  | 'UNKNOWN'\n\n/**\n * Audio error class\n */\nexport class AudioError extends Error {\n  constructor(\n    message: string,\n    public readonly code: AudioErrorCode\n  ) {\n    super(message)\n    this.name = 'AudioError'\n  }\n}\n\n/**\n * Audio adapter configuration\n */\nexport interface AudioAdapterConfig {\n  /** Default volume (0-1) */\n  defaultVolume?: number\n  /** Default playback rate */\n  defaultPlaybackRate?: number\n  /** Enable audio buffering */\n  buffering?: boolean\n  /** Buffer size in seconds */\n  bufferSize?: number\n}\n","/**\n * Platform adapter interface\n * Platform-agnostic abstraction for platform-specific features\n * like file system, clipboard, notifications, and window management\n */\n\n/**\n * Platform types\n */\nexport type Platform = 'web' | 'electron' | 'server' | 'mobile' | 'unknown'\n\n/**\n * Platform information\n */\nexport interface PlatformInfo {\n  /** Platform type */\n  platform: Platform\n  /** Platform version (e.g., browser version, OS version) */\n  version: string\n  /** User agent string (if available) */\n  userAgent?: string\n  /** Operating system */\n  os?: 'windows' | 'macos' | 'linux' | 'ios' | 'android' | 'unknown'\n  /** Device type */\n  deviceType?: 'desktop' | 'tablet' | 'mobile' | 'unknown'\n  /** Is touch device */\n  isTouch?: boolean\n  /** Is in standalone mode (PWA) */\n  isStandalone?: boolean\n}\n\n/**\n * File picker options\n */\nexport interface FilePickerOptions {\n  /** Accepted file types (MIME types or extensions) */\n  accept?: string[]\n  /** Allow multiple file selection */\n  multiple?: boolean\n  /** Starting directory (if supported) */\n  startIn?: string\n}\n\n/**\n * Selected file information\n */\nexport interface SelectedFile {\n  /** File name */\n  name: string\n  /** File size in bytes */\n  size: number\n  /** MIME type */\n  type: string\n  /** File path (if available, e.g., in Electron) */\n  path?: string\n  /** Read file contents as text */\n  text(): Promise<string>\n  /** Read file contents as ArrayBuffer */\n  arrayBuffer(): Promise<ArrayBuffer>\n}\n\n/**\n * Notification options\n */\nexport interface NotificationOptions {\n  /** Notification body text */\n  body?: string\n  /** Icon URL */\n  icon?: string\n  /** Badge URL */\n  badge?: string\n  /** Tag for grouping notifications */\n  tag?: string\n  /** Auto-close after milliseconds */\n  timeout?: number\n  /** Require user interaction to dismiss */\n  requireInteraction?: boolean\n  /** Additional data */\n  data?: unknown\n}\n\n/**\n * Notification click event\n */\nexport interface NotificationClickEvent {\n  /** Notification tag */\n  tag?: string\n  /** Additional data */\n  data?: unknown\n}\n\n/**\n * Platform capabilities\n */\nexport interface PlatformCapabilities {\n  /** Can access file system */\n  fileSystem: boolean\n  /** Can show notifications */\n  notifications: boolean\n  /** Can access clipboard */\n  clipboard: boolean\n  /** Can share content */\n  share: boolean\n  /** Can use native file picker */\n  filePicker: boolean\n  /** Has window management */\n  windowManagement: boolean\n  /** Supports deep linking */\n  deepLinking: boolean\n  /** Has persistent storage */\n  persistentStorage: boolean\n}\n\n/**\n * Platform adapter interface\n */\nexport interface IPlatformAdapter {\n  // Platform detection\n  /**\n   * Get current platform type\n   */\n  getPlatform(): Platform\n\n  /**\n   * Get detailed platform information\n   */\n  getPlatformInfo(): PlatformInfo\n\n  /**\n   * Get platform version\n   */\n  getVersion(): string\n\n  /**\n   * Get platform capabilities\n   */\n  getCapabilities(): PlatformCapabilities\n\n  // File system operations (if available)\n  /**\n   * Read file contents\n   * @param path - File path\n   * @returns File contents as Uint8Array\n   */\n  readFile?(path: string): Promise<Uint8Array>\n\n  /**\n   * Read file as text\n   * @param path - File path\n   * @returns File contents as string\n   */\n  readTextFile?(path: string): Promise<string>\n\n  /**\n   * Write file contents\n   * @param path - File path\n   * @param data - Data to write\n   */\n  writeFile?(path: string, data: Uint8Array): Promise<void>\n\n  /**\n   * Write text file\n   * @param path - File path\n   * @param text - Text to write\n   */\n  writeTextFile?(path: string, text: string): Promise<void>\n\n  /**\n   * Check if file exists\n   * @param path - File path\n   */\n  fileExists?(path: string): Promise<boolean>\n\n  /**\n   * Delete file\n   * @param path - File path\n   */\n  deleteFile?(path: string): Promise<void>\n\n  // File picker\n  /**\n   * Show file picker dialog\n   * @param options - Picker options\n   * @returns Selected file or null\n   */\n  selectFile?(options?: FilePickerOptions): Promise<SelectedFile | null>\n\n  /**\n   * Show multiple file picker dialog\n   * @param options - Picker options\n   * @returns Selected files\n   */\n  selectFiles?(options?: FilePickerOptions): Promise<SelectedFile[]>\n\n  /**\n   * Show folder picker dialog\n   * @returns Selected folder path or null\n   */\n  selectFolder?(): Promise<string | null>\n\n  // Clipboard\n  /**\n   * Copy text to clipboard\n   * @param text - Text to copy\n   */\n  copyToClipboard(text: string): Promise<void>\n\n  /**\n   * Read text from clipboard\n   * @returns Clipboard text or null\n   */\n  readFromClipboard(): Promise<string | null>\n\n  // Share\n  /**\n   * Share content using native share dialog\n   * @param data - Share data\n   */\n  share?(data: { title?: string; text?: string; url?: string }): Promise<void>\n\n  /**\n   * Check if sharing is supported\n   */\n  canShare?(): boolean\n\n  // Notifications\n  /**\n   * Request notification permission\n   */\n  requestNotificationPermission?(): Promise<'granted' | 'denied' | 'default'>\n\n  /**\n   * Show a notification\n   * @param title - Notification title\n   * @param options - Notification options\n   */\n  showNotification?(title: string, options?: NotificationOptions): Promise<void>\n\n  /**\n   * Subscribe to notification clicks\n   * @param callback - Click handler\n   * @returns Cleanup function\n   */\n  onNotificationClick?(callback: (event: NotificationClickEvent) => void): () => void\n\n  // Window management (desktop apps)\n  /**\n   * Set window title\n   * @param title - Window title\n   */\n  setWindowTitle?(title: string): Promise<void>\n\n  /**\n   * Minimize window\n   */\n  minimizeWindow?(): Promise<void>\n\n  /**\n   * Maximize window\n   */\n  maximizeWindow?(): Promise<void>\n\n  /**\n   * Restore window from minimized/maximized state\n   */\n  restoreWindow?(): Promise<void>\n\n  /**\n   * Close window\n   */\n  closeWindow?(): Promise<void>\n\n  /**\n   * Toggle fullscreen mode\n   */\n  toggleFullscreen?(): Promise<void>\n\n  /**\n   * Check if window is maximized\n   */\n  isMaximized?(): Promise<boolean>\n\n  /**\n   * Check if window is fullscreen\n   */\n  isFullscreen?(): Promise<boolean>\n\n  // Deep linking\n  /**\n   * Register deep link handler\n   * @param callback - Called when app is opened via deep link\n   * @returns Cleanup function\n   */\n  registerDeepLinkHandler?(callback: (url: string) => void): () => void\n\n  // Storage\n  /**\n   * Get app data directory path (desktop apps)\n   */\n  getAppDataPath?(): string\n\n  /**\n   * Get user documents directory path\n   */\n  getUserDocumentsPath?(): string\n\n  // System\n  /**\n   * Open URL in default browser\n   * @param url - URL to open\n   */\n  openExternalUrl?(url: string): Promise<void>\n\n  /**\n   * Get locale/language preference\n   */\n  getLocale(): string\n\n  /**\n   * Get preferred color scheme\n   */\n  getColorScheme(): 'light' | 'dark' | 'system'\n\n  /**\n   * Subscribe to color scheme changes\n   * @param callback - Called when color scheme changes\n   * @returns Cleanup function\n   */\n  onColorSchemeChange?(callback: (scheme: 'light' | 'dark') => void): () => void\n}\n\n/**\n * Platform error codes\n */\nexport type PlatformErrorCode =\n  | 'NOT_SUPPORTED'\n  | 'PERMISSION_DENIED'\n  | 'NOT_FOUND'\n  | 'INVALID_PATH'\n  | 'UNKNOWN'\n\n/**\n * Platform error class\n */\nexport class PlatformError extends Error {\n  constructor(\n    message: string,\n    public readonly code: PlatformErrorCode\n  ) {\n    super(message)\n    this.name = 'PlatformError'\n  }\n}\n"]}