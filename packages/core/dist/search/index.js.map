{"version":3,"sources":["../../src/bible/books.ts","../../src/search/parser.ts","../../src/bible/translation-utils.ts","../../src/search/engine.ts","../../src/search/reference-resolver.ts"],"names":["regex"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Bible book metadata - names, abbreviations, and chapter counts\n * Framework-agnostic - no browser/Vue dependencies\n */\n\n/**\n * OSIS book codes (standard identifiers)\n */\nexport const osisBooks = [\n  'Gen', 'Exod', 'Lev', 'Num', 'Deut', 'Josh', 'Judg', 'Ruth',\n  '1Sam', '2Sam', '1Kgs', '2Kgs', '1Chr', '2Chr', 'Ezra', 'Neh',\n  'Esth', 'Job', 'Ps', 'Prov', 'Eccl', 'Song', 'Isa', 'Jer',\n  'Lam', 'Ezek', 'Dan', 'Hos', 'Joel', 'Amos', 'Obad', 'Jonah',\n  'Mic', 'Nah', 'Hab', 'Zeph', 'Hag', 'Zech', 'Mal', 'Matt',\n  'Mark', 'Luke', 'John', 'Acts', 'Rom', '1Cor', '2Cor', 'Gal',\n  'Eph', 'Phil', 'Col', '1Thess', '2Thess', '1Tim', '2Tim', 'Titus',\n  'Phlm', 'Heb', 'Jas', '1Pet', '2Pet', '1John', '2John', '3John',\n  'Jude', 'Rev',\n  // Apocrypha\n  'Jdt', 'Tob', '1Macc', '2Macc', 'Wis', 'Sir', 'Bar'\n] as const\n\n/**\n * Full English book names\n */\nexport const fullEnglishBooks = [\n  'Genesis', 'Exodus', 'Leviticus', 'Numbers', 'Deuteronomy',\n  'Joshua', 'Judges', 'Ruth', '1 Samuel', '2 Samuel',\n  '1 Kings', '2 Kings', '1 Chronicles', '2 Chronicles', 'Ezra',\n  'Nehemiah', 'Esther', 'Job', 'Psalms', 'Proverbs',\n  'Ecclesiastes', 'Song of Solomon', 'Isaiah', 'Jeremiah', 'Lamentations',\n  'Ezekiel', 'Daniel', 'Hosea', 'Joel', 'Amos',\n  'Obadiah', 'Jonah', 'Micah', 'Nahum', 'Habakkuk',\n  'Zephaniah', 'Haggai', 'Zechariah', 'Malachi', 'Matthew',\n  'Mark', 'Luke', 'John', 'Acts', 'Romans',\n  '1 Corinthians', '2 Corinthians', 'Galatians', 'Ephesians', 'Philippians',\n  'Colossians', '1 Thessalonians', '2 Thessalonians', '1 Timothy', '2 Timothy',\n  'Titus', 'Philemon', 'Hebrews', 'James', '1 Peter',\n  '2 Peter', '1 John', '2 John', '3 John', 'Jude',\n  'Revelation',\n  // Apocrypha\n  'Judith', 'Tobith', '1 Maccabees', '2 Maccabees', 'Wisdom', 'Sirah', 'Baruch'\n] as const\n\n/**\n * Full Polish book names\n */\nexport const fullPolishBooks = [\n  'Rodzaju', 'Wyjścia', 'Kapłańska', 'Liczb', 'Powtórzonego Prawa',\n  'Jozuego', 'Sędziów', 'Rut', '1 Samuela', '2 Samuela',\n  '1 Królewska', '2 Królewska', '1 Kronik', '2 Kronik', 'Ezdrasza',\n  'Nehemiasza', 'Estery', 'Hioba', 'Psalmy', 'Przypowieści',\n  'Pieśń nad Pieśniami', 'Kaznodziei', 'Izajasza', 'Jeremiasza', 'Lamentacje',\n  'Ezechiela', 'Daniela', 'Ozeasza', 'Joela', 'Amosa',\n  'Abdiasza', 'Jonasza', 'Micheasza', 'Nahuma', 'Habakuka',\n  'Sofoniasza', 'Aggeusza', 'Zachariasza', 'Malachiasza', 'Mateusza',\n  'Marka', 'Łukasza', 'Jana', 'Dzieje Apostolskie', 'List do Rzymian',\n  '1 List do Koryntian', '2 List do Koryntian', 'List do Galatów', 'List do Efezjan', 'List do Filipian',\n  'List do Kolosan', '1 List do Tesaloniczan', '2 List do Tesaloniczan', '1 List do Tymoteusza', '2 List do Tymoteusza',\n  'List do Tytusa', 'List do Filemona', 'List do Hebrajczyków', 'List Jakuba', '1 List Piotra',\n  '2 List Piotra', '1 List Jana', '2 List Jana', '3 List Jana', 'List Judy',\n  'Objawienie Jana'\n] as const\n\n/**\n * Book abbreviations by language\n */\nexport const bookAbbreviations = {\n  pl: [\n    '1 Moj', '2 Moj', '3 Moj', '4 Moj', '5 Moj', 'Joz', 'Sdz', 'Rut',\n    '1 Sam', '2 Sam', '1 Krl', '2 Krl', '1 Krn', '2 Krn', 'Ezd', 'Ne',\n    'Est', 'Job', 'Ps', 'Prz', 'Kz', 'Pnp', 'Iz', 'Jr',\n    'Tr', 'Ez', 'Dn', 'Oz', 'Jl', 'Am', 'Ab', 'Jon',\n    'Mi', 'Na', 'Ha', 'So', 'Ag', 'Za', 'Ml', 'Mt',\n    'Mr', 'Łk', 'Jn', 'Dz', 'Rz', '1 Kor', '2 Kor', 'Ga',\n    'Ef', 'Flp', 'Kol', '1 Tes', '2 Tes', '1 Tm', '2 Tm', 'Tt',\n    'Flm', 'Hbr', 'Jk', '1 Pt', '2 Pt', '1 Jn', '2 Jn', '3 Jn',\n    'Jud', 'Obj',\n    // Apocrypha\n    'Jdt', 'Tob', '1Ma', '2Ma', 'Mdr', 'Syr', 'Bar'\n  ],\n  en: [\n    'Gen', 'Exo', 'Lev', 'Num', 'Deu', 'Jos', 'Jdg', 'Rth',\n    '1Sa', '2Sa', '1Ki', '2Ki', '1Ch', '2Ch', 'Ezr', 'Neh',\n    'Est', 'Job', 'Psa', 'Pro', 'Ecc', 'Son', 'Isa', 'Jer',\n    'Lam', 'Eze', 'Dan', 'Hos', 'Joe', 'Amo', 'Oba', 'Jon',\n    'Mic', 'Nah', 'Hab', 'Zep', 'Hag', 'Zec', 'Mal', 'Mat',\n    'Mar', 'Luk', 'Joh', 'Act', 'Rom', '1Co', '2Co', 'Gal',\n    'Eph', 'Phi', 'Col', '1Th', '2Th', '1Ti', '2Ti', 'Tit',\n    'Phm', 'Heb', 'Jas', '1Pe', '2Pe', '1Jo', '2Jo', '3Jo',\n    'Jud', 'Rev'\n  ]\n} as const\n\n/**\n * Number of chapters per book (canonical books only)\n */\nexport const chapterCounts = [\n  50, 40, 27, 36, 34, 24, 21, 4, 31, 24,\n  22, 25, 29, 36, 10, 13, 10, 42, 150, 31,\n  12, 8, 66, 52, 5, 48, 12, 14, 3, 9,\n  1, 4, 7, 3, 3, 3, 2, 14, 3, 28,\n  16, 24, 21, 28, 16, 16, 13, 6, 6, 4,\n  4, 5, 3, 6, 4, 3, 1, 13, 5, 5,\n  3, 5, 1, 1, 1, 22\n] as const\n\n/**\n * Total number of canonical books (excluding Apocrypha)\n */\nexport const CANONICAL_BOOK_COUNT = 66\n\n/**\n * Total number of books including Apocrypha\n */\nexport const TOTAL_BOOK_COUNT = osisBooks.length\n\n/**\n * Get the OSIS code for a book by index\n */\nexport function getOsisCode(bookIndex: number): string | undefined {\n  return osisBooks[bookIndex]\n}\n\n/**\n * Get the book index from an OSIS code\n */\nexport function getBookIndexFromOsis(osisCode: string): number {\n  return osisBooks.indexOf(osisCode as typeof osisBooks[number])\n}\n\n/**\n * Get the chapter count for a book\n */\nexport function getChapterCountForBook(bookIndex: number): number {\n  return chapterCounts[bookIndex] || 0\n}\n\n/**\n * Check if a book is apocryphal\n */\nexport function isApocryphal(bookIndex: number): boolean {\n  return bookIndex >= CANONICAL_BOOK_COUNT\n}\n\n/**\n * Combined books data object for backward compatibility\n */\nexport const books = {\n  osis: osisBooks,\n  fullEnglish: fullEnglishBooks,\n  fullPolish: fullPolishBooks,\n  bookAbbreviations,\n  chapterCount: chapterCounts,\n}\n\nexport default books\n","/**\n * Bible reference parsing\n * Framework-agnostic wrapper for jota-parser\n */\n\nimport { Parser, enUS, plPL } from 'jota-parser'\nimport type { Passage } from '../types'\nimport { osisBooks } from '../bible/books'\n\n// Create default parser with English and Polish locales\nconst defaultParser = new Parser({ locales: [plPL, enUS] })\n\n/**\n * Parse Bible references from text input\n * @param input - Text containing Bible references\n * @param parser - Optional custom parser instance\n * @returns Array of passages\n */\nexport function parseReferences(input: string, parser = defaultParser): Passage[] {\n  return parser.parse(input).map((v: number[]) => {\n    const b = v[0]\n    const c = v[1] - 1\n    const s = v[2] ? v[2] - 1 : undefined\n    const e = v[3] ? v[3] - 1 : s\n    return [b, c, s, e] as Passage\n  })\n}\n\n/**\n * Convert OSIS code to passage indices\n * @param osis - OSIS code like \"Gen.1.1\"\n * @returns Array of [bookIndex, chapterIndex, verseIndex]\n */\nexport function osisToPassage(osis: string): number[] {\n  const match = [...osis.matchAll(/(\\w+)\\.(\\d+)\\.?(\\d+)?/g)][0] || [null, osis]\n  return [osisBooks.indexOf(match[1] as typeof osisBooks[number]), parseInt(match[2]) - 1, parseInt(match[3]) - 1]\n}\n\n/**\n * Create a new parser with custom locales\n */\nexport function createParser(options: { locales: unknown[] }): InstanceType<typeof Parser> {\n  return new Parser(options)\n}\n\nexport { Parser, enUS, plPL }\n","/**\n * Utility functions to access Bible translation data regardless of format (3D array or map)\n * Framework-agnostic - no Vue/Quasar dependencies\n */\n\nimport type {\n  TranslationContent,\n  TranslationContentArray,\n  TranslationContentMap,\n} from '../types'\n\n/**\n * Check if content is in array format\n */\nexport function isArrayFormat(content: TranslationContent): content is TranslationContentArray {\n  return Array.isArray(content)\n}\n\n/**\n * Check if content is in map format\n */\nexport function isMapFormat(content: TranslationContent): content is TranslationContentMap {\n  return !Array.isArray(content) && typeof content === 'object' && content !== null\n}\n\n/**\n * Get a single verse from the translation content\n * @param content - Translation content in either format\n * @param bookIndex - 0-based book index\n * @param chapterIndex - 0-based chapter index\n * @param verseIndex - 0-based verse index\n * @returns The verse text or undefined if not found\n */\nexport function getVerse(\n  content: TranslationContent,\n  bookIndex: number,\n  chapterIndex: number,\n  verseIndex: number\n): string | undefined {\n  if (isArrayFormat(content)) {\n    // 3D array format (0-indexed)\n    return content[bookIndex]?.[chapterIndex]?.[verseIndex]\n  } else if (isMapFormat(content)) {\n    // Map format (1-indexed)\n    const bookNumber = bookIndex + 1\n    const chapterNumber = chapterIndex + 1\n    const verseNumber = verseIndex + 1\n    return content[bookNumber]?.[chapterNumber]?.[verseNumber]\n  }\n  return undefined\n}\n\n/**\n * Get all verses from a chapter\n * @param content - Translation content in either format\n * @param bookIndex - 0-based book index\n * @param chapterIndex - 0-based chapter index\n * @returns Array of verse strings or undefined if chapter not found\n */\nexport function getChapter(\n  content: TranslationContent,\n  bookIndex: number,\n  chapterIndex: number\n): string[] | undefined {\n  if (isArrayFormat(content)) {\n    return content[bookIndex]?.[chapterIndex]\n  } else if (isMapFormat(content)) {\n    const bookNumber = bookIndex + 1\n    const chapterNumber = chapterIndex + 1\n    const chapter = content[bookNumber]?.[chapterNumber]\n    if (!chapter) return undefined\n\n    // Convert map to array, maintaining verse order\n    const verses: string[] = []\n    const verseNumbers = Object.keys(chapter).map(Number).sort((a, b) => a - b)\n    for (const verseNum of verseNumbers) {\n      verses[verseNum - 1] = chapter[verseNum]\n    }\n    return verses\n  }\n  return undefined\n}\n\n/**\n * Get all chapters from a book\n * @param content - Translation content in either format\n * @param bookIndex - 0-based book index\n * @returns 2D array of chapters and verses or undefined if book not found\n */\nexport function getBook(\n  content: TranslationContent,\n  bookIndex: number\n): string[][] | undefined {\n  if (isArrayFormat(content)) {\n    return content[bookIndex]\n  } else if (isMapFormat(content)) {\n    const bookNumber = bookIndex + 1\n    const book = content[bookNumber]\n    if (!book) return undefined\n\n    // Convert map to 2D array\n    const chapters: string[][] = []\n    const chapterNumbers = Object.keys(book).map(Number).sort((a, b) => a - b)\n\n    for (const chapterNum of chapterNumbers) {\n      const chapter = book[chapterNum]\n      const verses: string[] = []\n      const verseNumbers = Object.keys(chapter).map(Number).sort((a, b) => a - b)\n\n      for (const verseNum of verseNumbers) {\n        verses[verseNum - 1] = chapter[verseNum]\n      }\n      chapters[chapterNum - 1] = verses\n    }\n    return chapters\n  }\n  return undefined\n}\n\n/**\n * Get the number of books in the translation\n */\nexport function getBookCount(content: TranslationContent): number {\n  if (isArrayFormat(content)) {\n    return content.length\n  } else if (isMapFormat(content)) {\n    return Object.keys(content).length\n  }\n  return 0\n}\n\n/**\n * Get the number of chapters in a book\n */\nexport function getChapterCount(content: TranslationContent, bookIndex: number): number {\n  if (isArrayFormat(content)) {\n    return content[bookIndex]?.length || 0\n  } else if (isMapFormat(content)) {\n    const bookNumber = bookIndex + 1\n    const book = content[bookNumber]\n    return book ? Object.keys(book).length : 0\n  }\n  return 0\n}\n\n/**\n * Get the number of verses in a chapter\n */\nexport function getVerseCount(\n  content: TranslationContent,\n  bookIndex: number,\n  chapterIndex: number\n): number {\n  if (isArrayFormat(content)) {\n    return content[bookIndex]?.[chapterIndex]?.length || 0\n  } else if (isMapFormat(content)) {\n    const bookNumber = bookIndex + 1\n    const chapterNumber = chapterIndex + 1\n    const chapter = content[bookNumber]?.[chapterNumber]\n    return chapter ? Object.keys(chapter).length : 0\n  }\n  return 0\n}\n\n/**\n * Convert any translation content to 3D array format for backward compatibility\n */\nexport function toArrayFormat(content: TranslationContent): TranslationContentArray {\n  if (isArrayFormat(content)) {\n    return content\n  }\n\n  if (isMapFormat(content)) {\n    const result: TranslationContentArray = []\n    const bookNumbers = Object.keys(content).map(Number).sort((a, b) => a - b)\n\n    for (const bookNum of bookNumbers) {\n      const book = content[bookNum]\n      const chapters: string[][] = []\n      const chapterNumbers = Object.keys(book).map(Number).sort((a, b) => a - b)\n\n      for (const chapterNum of chapterNumbers) {\n        const chapter = book[chapterNum]\n        const verses: string[] = []\n        const verseNumbers = Object.keys(chapter).map(Number).sort((a, b) => a - b)\n\n        for (const verseNum of verseNumbers) {\n          verses[verseNum - 1] = chapter[verseNum]\n        }\n        chapters[chapterNum - 1] = verses\n      }\n      result[bookNum - 1] = chapters\n    }\n    return result\n  }\n\n  return []\n}\n\n/**\n * Convert any translation content to map format\n */\nexport function toMapFormat(content: TranslationContent): TranslationContentMap {\n  if (isMapFormat(content)) {\n    return content\n  }\n\n  const result: TranslationContentMap = {}\n\n  if (isArrayFormat(content)) {\n    const arrayContent = content as TranslationContentArray\n\n    for (let bookIndex = 0; bookIndex < arrayContent.length; bookIndex++) {\n      const book = arrayContent[bookIndex]\n      const bookNumber = bookIndex + 1\n      result[bookNumber] = {}\n\n      for (let chapterIndex = 0; chapterIndex < book.length; chapterIndex++) {\n        const chapter = book[chapterIndex]\n        const chapterNumber = chapterIndex + 1\n        result[bookNumber][chapterNumber] = {}\n\n        for (let verseIndex = 0; verseIndex < chapter.length; verseIndex++) {\n          const verse = chapter[verseIndex]\n          const verseNumber = verseIndex + 1\n          result[bookNumber][chapterNumber][verseNumber] = verse\n        }\n      }\n    }\n  }\n\n  return result\n}\n","/**\n * Bible content search engine\n * Framework-agnostic search implementation\n */\n\nimport type { Passage, Progress, SearchOptions, TranslationContent } from '../types'\nimport { getBookCount, getChapterCount, getVerseCount, getVerse } from '../bible/translation-utils'\nimport { parseReferences } from './parser'\n\n/**\n * Search result item\n */\nexport interface SearchResultItem {\n  passage: [number, number, number, number]\n  bookIndex: number\n  chapterIndex: number\n  verseIndex: number\n}\n\n/**\n * General search function\n * If text does not start with \"/\" then try to find passage references.\n * Otherwise search for the text in the Bible content.\n *\n * @param bible - Translation content\n * @param text - Search input\n * @param options - Search options\n * @param progress - Progress reporting callback\n * @returns Array of passages\n */\nexport async function search(\n  bible: TranslationContent,\n  text: string,\n  options: SearchOptions,\n  progress: Progress\n): Promise<Passage[]> {\n  // Clean up special characters that may come from mobile devices\n  text = text.replace(/[\\u202d\\u202c]/gm, '')\n\n  // If text is a regular expression (starts with /)\n  if (text.startsWith('/')) {\n    const end = text.lastIndexOf('/')\n    // If there is no regex flags, add \"gi\" automatically\n    const flags = end === text.length - 1 ? 'gi' : text.substring(end + 1, text.length)\n    let regex: RegExp\n    let error: unknown\n\n    try {\n      regex = new RegExp(`(${text.substring(1, end)})`, flags)\n    } catch (ex) {\n      error = ex\n      throw Error(`Invalid regular expression RegExp(${text.substring(1, end)}, ${flags})${error ? ', ' + error : ''}`)\n    }\n\n    return searchContent(regex, bible, progress)\n  }\n\n  // Determine if apocrypha should be included\n  options.apocrypha = options.apocrypha === undefined ? getBookCount(bible) > 66 : options.apocrypha\n\n  // Try to find passage references\n  const fragments = parseReferences(text)\n  if (fragments.length) return fragments\n\n  // If no references found, search in content\n  let regex: RegExp\n  if (options.words) {\n    const notWord = '[^a-zA-ZąćęłńóśźżĄĘŁŃÓŚŹŻ]' // cspell:disable-line\n    regex = new RegExp(`(^|${notWord})(${text.trim()})($|${notWord})`, 'i')\n  } else {\n    regex = new RegExp(`(${text})`, 'i')\n  }\n\n  return searchContent(regex, bible, progress)\n}\n\n/**\n * Search for regex pattern in Bible content\n *\n * @param regex - Regular expression to search for\n * @param bible - Translation content\n * @param progress - Progress reporting callback\n * @returns Array of matching passages\n */\nexport async function searchContent(\n  regex: RegExp,\n  bible: TranslationContent,\n  progress: Progress\n): Promise<Passage[]> {\n  const found: Passage[] = []\n  const bookCount = getBookCount(bible)\n\n  // Process books with setTimeout to allow UI updates\n  await Promise.all(\n    Array.from({ length: bookCount }, (_, bi) =>\n      new Promise<void>(resolve =>\n        setTimeout(() => {\n          const chapterCount = getChapterCount(bible, bi)\n          for (let ci = 0; ci < chapterCount; ci++) {\n            const verseCount = getVerseCount(bible, bi, ci)\n            for (let vi = 0; vi < verseCount; vi++) {\n              const verse = getVerse(bible, bi, ci, vi)\n              if (verse && regex.test(verse)) {\n                const fragment: Passage = [bi, ci, vi, vi]\n                Object.preventExtensions(fragment)\n                Object.freeze(fragment)\n                found.push(fragment)\n              }\n            }\n          }\n          progress.step(bi + 1)\n          resolve()\n        }, 100)\n      )\n    )\n  )\n\n  // Store regex for UI highlighting\n  progress.regex = regex\n  Object.preventExtensions(found)\n  Object.freeze(found)\n  return found\n}\n\n/**\n * Ensure regex flag includes \"g\" for global matching\n */\nexport function ensureGlobalRegex(regex?: RegExp): RegExp | string {\n  return regex\n    ? regex.flags.includes('g')\n      ? regex\n      : new RegExp(regex.source, regex.flags + 'g')\n    : ''\n}\n\n/**\n * Sort passages and remove duplicates\n *\n * @param fragments - Array of passages to sort\n * @returns Sorted and deduplicated array\n */\nexport function sortAndDeduplicate(fragments: Passage[]): Passage[] {\n  // Sort by book, chapter, verse\n  fragments.sort((a, b) =>\n    a[0] > b[0] ? 1 : a[0] < b[0] ? -1 :\n      a[1] > b[1] ? 1 : a[1] < b[1] ? -1 :\n        a[2] != null && b[2] != null ? (a[2] > b[2] ? 1 : a[2] < b[2] ? -1 : 0) : 0\n  )\n\n  if (fragments.length < 2) {\n    return fragments\n  }\n\n  // Deduplicate\n  let prev = fragments[0]\n  const result = [prev]\n\n  for (let i = 1; i < fragments.length; i++) {\n    const curr = fragments[i]\n    if (!(prev[0] === curr[0] && prev[1] === curr[1] && (prev[2] === curr[2] || (prev[2] == null && curr[2] == null)))) {\n      result.push(curr)\n    }\n    prev = curr\n  }\n\n  return result\n}\n","/**\n * Reference resolver - converts OSIS strings to passages\n * Framework-agnostic\n */\n\nimport type { Passage, TranslationContent } from '../types'\nimport { getChapterCount, getVerseCount } from '../bible/translation-utils'\nimport { osisToPassage } from './parser'\n\n/**\n * Get list of passages from OSIS string\n *\n * @param translationContent - Translation content\n * @param osis - Comma-separated list of OSIS codes like \"Deut.25.13-14\"\n * @param shouldSort - Whether to sort results\n * @returns Array of passages\n */\nexport function resolveOsisToPassages(\n  translationContent: TranslationContent,\n  osis: string,\n  shouldSort = false\n): Passage[] {\n  if (!osis) return []\n\n  const fragments: Passage[] = []\n\n  osis.split(',').forEach((it: string) => {\n    const [it1, it2] = it.split('-')\n    const from = it1\n    let to: string | true = it2\n\n    const a = osisToPassage(from)\n\n    // Handle case of entire book, e.g., osis = \"Col\"\n    if (isNaN(a[1])) {\n      a[1] = 0\n      to = to || true\n    }\n\n    if (to) {\n      const b = to === true\n        ? [a[0], getChapterCount(translationContent, a[0]) - 1]\n        : osisToPassage(to as string)\n\n      // Only scopes within the same chapter are allowed\n      if (a[0] !== b[0] || a[1] !== b[1]) {\n        a[2] = a[2] || 0\n        if (a[2] === 0) {\n          a.splice(2, 1)\n          fragments.push(a as Passage)\n        } else {\n          push(a, getVerseCount(translationContent, a[0], a[1]) - 1)\n        }\n\n        if (a[0] < b[0]) {\n          // Add the rest of chapters from the starting book\n          addChapters(a[0], a[1] + 1, getChapterCount(translationContent, a[0]))\n        } else {\n          // Add all the chapters in between if start and end are in the same book\n          addChapters(a[0], a[1] + 1, b[1])\n        }\n\n        if (a[0] + 1 < b[0]) {\n          // Add books in between\n          for (let bi = a[0] + 1; bi < b[0]; bi++) {\n            addChapters(bi, 0, getChapterCount(translationContent, bi))\n          }\n        }\n\n        if (a[0] < b[0]) {\n          // Add the starting chapters from the ending book\n          addChapters(b[0], 0, isNaN(b[1]) ? getChapterCount(translationContent, b[0]) : b[1])\n        }\n\n        if (!isNaN(b[1])) {\n          if (isNaN(b[2]) || b[2] === getVerseCount(translationContent, b[0], b[1]) - 1) {\n            fragments.push([b[0], b[1]])\n          } else {\n            fragments.push([b[0], b[1], 0, b[2]])\n          }\n        }\n      } else {\n        push(a, b[2])\n      }\n    } else {\n      push(a, a[2])\n    }\n  })\n\n  return shouldSort ? sortPassages(fragments) : fragments\n\n  function addChapters(bi: number, ci: number, len: number) {\n    for (; ci < len; ci++) {\n      fragments.push([bi, ci])\n    }\n  }\n\n  function push(tokens: number[], end: number) {\n    tokens.push(end)\n    fragments.push(tokens as Passage)\n  }\n}\n\n/**\n * Sort passages by book, chapter, verse\n */\nfunction sortPassages(fragments: Passage[]): Passage[] {\n  fragments.sort((a, b) =>\n    a[0] > b[0] ? 1 : a[0] < b[0] ? -1 :\n      a[1] > b[1] ? 1 : a[1] < b[1] ? -1 :\n        a[2] != null && b[2] != null ? (a[2] > b[2] ? 1 : a[2] < b[2] ? -1 : 0) : 0\n  )\n  return fragments\n}\n"]}