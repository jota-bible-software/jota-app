{"version":3,"sources":["../../src/bible/translation-utils.ts","../../src/format/passage-formatter.ts","../../src/format/template-engine.ts"],"names":["content","chapter","verses","template","passage","translationContent","bookNames","bi","ci","si","ei","start","end","text","includesNumbers","includesNewLines","oneVerse","separator","book"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Utility functions to access Bible translation data regardless of format (3D array or map)\n * Framework-agnostic - no Vue/Quasar dependencies\n */\n\nimport type {\n  TranslationContent,\n  TranslationContentArray,\n  TranslationContentMap,\n} from '../types'\n\n/**\n * Check if content is in array format\n */\nexport function isArrayFormat(content: TranslationContent): content is TranslationContentArray {\n  return Array.isArray(content)\n}\n\n/**\n * Check if content is in map format\n */\nexport function isMapFormat(content: TranslationContent): content is TranslationContentMap {\n  return !Array.isArray(content) && typeof content === 'object' && content !== null\n}\n\n/**\n * Get a single verse from the translation content\n * @param content - Translation content in either format\n * @param bookIndex - 0-based book index\n * @param chapterIndex - 0-based chapter index\n * @param verseIndex - 0-based verse index\n * @returns The verse text or undefined if not found\n */\nexport function getVerse(\n  content: TranslationContent,\n  bookIndex: number,\n  chapterIndex: number,\n  verseIndex: number\n): string | undefined {\n  if (isArrayFormat(content)) {\n    // 3D array format (0-indexed)\n    return content[bookIndex]?.[chapterIndex]?.[verseIndex]\n  } else if (isMapFormat(content)) {\n    // Map format (1-indexed)\n    const bookNumber = bookIndex + 1\n    const chapterNumber = chapterIndex + 1\n    const verseNumber = verseIndex + 1\n    return content[bookNumber]?.[chapterNumber]?.[verseNumber]\n  }\n  return undefined\n}\n\n/**\n * Get all verses from a chapter\n * @param content - Translation content in either format\n * @param bookIndex - 0-based book index\n * @param chapterIndex - 0-based chapter index\n * @returns Array of verse strings or undefined if chapter not found\n */\nexport function getChapter(\n  content: TranslationContent,\n  bookIndex: number,\n  chapterIndex: number\n): string[] | undefined {\n  if (isArrayFormat(content)) {\n    return content[bookIndex]?.[chapterIndex]\n  } else if (isMapFormat(content)) {\n    const bookNumber = bookIndex + 1\n    const chapterNumber = chapterIndex + 1\n    const chapter = content[bookNumber]?.[chapterNumber]\n    if (!chapter) return undefined\n\n    // Convert map to array, maintaining verse order\n    const verses: string[] = []\n    const verseNumbers = Object.keys(chapter).map(Number).sort((a, b) => a - b)\n    for (const verseNum of verseNumbers) {\n      verses[verseNum - 1] = chapter[verseNum]\n    }\n    return verses\n  }\n  return undefined\n}\n\n/**\n * Get all chapters from a book\n * @param content - Translation content in either format\n * @param bookIndex - 0-based book index\n * @returns 2D array of chapters and verses or undefined if book not found\n */\nexport function getBook(\n  content: TranslationContent,\n  bookIndex: number\n): string[][] | undefined {\n  if (isArrayFormat(content)) {\n    return content[bookIndex]\n  } else if (isMapFormat(content)) {\n    const bookNumber = bookIndex + 1\n    const book = content[bookNumber]\n    if (!book) return undefined\n\n    // Convert map to 2D array\n    const chapters: string[][] = []\n    const chapterNumbers = Object.keys(book).map(Number).sort((a, b) => a - b)\n\n    for (const chapterNum of chapterNumbers) {\n      const chapter = book[chapterNum]\n      const verses: string[] = []\n      const verseNumbers = Object.keys(chapter).map(Number).sort((a, b) => a - b)\n\n      for (const verseNum of verseNumbers) {\n        verses[verseNum - 1] = chapter[verseNum]\n      }\n      chapters[chapterNum - 1] = verses\n    }\n    return chapters\n  }\n  return undefined\n}\n\n/**\n * Get the number of books in the translation\n */\nexport function getBookCount(content: TranslationContent): number {\n  if (isArrayFormat(content)) {\n    return content.length\n  } else if (isMapFormat(content)) {\n    return Object.keys(content).length\n  }\n  return 0\n}\n\n/**\n * Get the number of chapters in a book\n */\nexport function getChapterCount(content: TranslationContent, bookIndex: number): number {\n  if (isArrayFormat(content)) {\n    return content[bookIndex]?.length || 0\n  } else if (isMapFormat(content)) {\n    const bookNumber = bookIndex + 1\n    const book = content[bookNumber]\n    return book ? Object.keys(book).length : 0\n  }\n  return 0\n}\n\n/**\n * Get the number of verses in a chapter\n */\nexport function getVerseCount(\n  content: TranslationContent,\n  bookIndex: number,\n  chapterIndex: number\n): number {\n  if (isArrayFormat(content)) {\n    return content[bookIndex]?.[chapterIndex]?.length || 0\n  } else if (isMapFormat(content)) {\n    const bookNumber = bookIndex + 1\n    const chapterNumber = chapterIndex + 1\n    const chapter = content[bookNumber]?.[chapterNumber]\n    return chapter ? Object.keys(chapter).length : 0\n  }\n  return 0\n}\n\n/**\n * Convert any translation content to 3D array format for backward compatibility\n */\nexport function toArrayFormat(content: TranslationContent): TranslationContentArray {\n  if (isArrayFormat(content)) {\n    return content\n  }\n\n  if (isMapFormat(content)) {\n    const result: TranslationContentArray = []\n    const bookNumbers = Object.keys(content).map(Number).sort((a, b) => a - b)\n\n    for (const bookNum of bookNumbers) {\n      const book = content[bookNum]\n      const chapters: string[][] = []\n      const chapterNumbers = Object.keys(book).map(Number).sort((a, b) => a - b)\n\n      for (const chapterNum of chapterNumbers) {\n        const chapter = book[chapterNum]\n        const verses: string[] = []\n        const verseNumbers = Object.keys(chapter).map(Number).sort((a, b) => a - b)\n\n        for (const verseNum of verseNumbers) {\n          verses[verseNum - 1] = chapter[verseNum]\n        }\n        chapters[chapterNum - 1] = verses\n      }\n      result[bookNum - 1] = chapters\n    }\n    return result\n  }\n\n  return []\n}\n\n/**\n * Convert any translation content to map format\n */\nexport function toMapFormat(content: TranslationContent): TranslationContentMap {\n  if (isMapFormat(content)) {\n    return content\n  }\n\n  const result: TranslationContentMap = {}\n\n  if (isArrayFormat(content)) {\n    const arrayContent = content as TranslationContentArray\n\n    for (let bookIndex = 0; bookIndex < arrayContent.length; bookIndex++) {\n      const book = arrayContent[bookIndex]\n      const bookNumber = bookIndex + 1\n      result[bookNumber] = {}\n\n      for (let chapterIndex = 0; chapterIndex < book.length; chapterIndex++) {\n        const chapter = book[chapterIndex]\n        const chapterNumber = chapterIndex + 1\n        result[bookNumber][chapterNumber] = {}\n\n        for (let verseIndex = 0; verseIndex < chapter.length; verseIndex++) {\n          const verse = chapter[verseIndex]\n          const verseNumber = verseIndex + 1\n          result[bookNumber][chapterNumber][verseNumber] = verse\n        }\n      }\n    }\n  }\n\n  return result\n}\n","/**\n * Passage formatting utilities\n * Framework-agnostic text formatting for Bible passages\n */\n\nimport type { FormatTemplateData, Formatted, Passage, TranslationContent } from '../types'\nimport { getChapter } from '../bible/translation-utils'\n\n/**\n * Replace enter character placeholder with newline\n */\nfunction replaceEnterChar(str: string): string {\n  return str.replace(/âŽ/g, '\\n')\n}\n\n/**\n * Format a passage with template, returning structured output\n *\n * @param template - Format template configuration\n * @param passage - Passage reference\n * @param translationContent - Bible translation content\n * @param bookNames - Array of book names\n * @param translationAbbreviation - Translation abbreviation\n * @returns Formatted output structure or undefined if chapter not found\n */\nexport function formatPassageComposable(\n  template: FormatTemplateData,\n  passage: Passage,\n  translationContent: TranslationContent,\n  bookNames: string[],\n  translationAbbreviation: string\n): Formatted | undefined {\n  const t = {\n    ...template,\n    referenceCharsBefore: replaceEnterChar(template.referenceCharsBefore),\n    referenceCharsAfter: replaceEnterChar(template.referenceCharsAfter),\n    translationAbbreviationCharsBefore: replaceEnterChar(template.translationAbbreviationCharsBefore),\n    translationAbbreviationCharsAfter: replaceEnterChar(template.translationAbbreviationCharsAfter),\n    quoteCharsBefore: replaceEnterChar(template.quoteCharsBefore),\n    quoteCharsAfter: replaceEnterChar(template.quoteCharsAfter),\n    verseNumberCharsBefore: replaceEnterChar(template.verseNumberCharsBefore),\n    verseNumberCharsAfter: replaceEnterChar(template.verseNumberCharsAfter),\n  }\n\n  const [bi, ci, si, ei] = passage\n  const chapter = ci + 1\n  const chapterContent = getChapter(translationContent, bi, ci)\n\n  if (!chapterContent) return undefined\n\n  const bookName = bookNames[bi]\n  const start = si === undefined ? 1 : si + 1\n  const end = ei === undefined ? (si === undefined ? chapterContent.length : si + 1) : ei + 1\n  const ending = start === end ? '' : t.rangeChar + end\n  const ta = t.translationAbbreviation\n  const ab = ta === 'none' ? '' : ta === 'lowercase' ? translationAbbreviation.toLowerCase() : translationAbbreviation.toUpperCase()\n  const abb = ab ? ` ${t.translationAbbreviationCharsBefore}${ab}${t.translationAbbreviationCharsAfter}` : ''\n\n  // Format Reference\n  const reference = `${t.referenceCharsBefore}${bookName} ${chapter}${t.separatorChar}${start}${ending}${abb}${t.referenceCharsAfter}`\n\n  let text = ''\n  const includesNumbers = t.numbers\n  const includesNewLines = t.verseNewLine\n  const oneVerse = start === end\n  const verses = chapterContent.slice(start - 1, end)\n\n  const numberedVerse = (i: number, s: string) =>\n    `${t.verseNumberCharsBefore}${start + i}${t.verseNumberCharsAfter} ${s}`\n\n  if (includesNumbers && includesNewLines) {\n    text = oneVerse ? verses.join(' ') : verses.map((v, i) => numberedVerse(i, v)).join('\\n')\n  } else if (includesNewLines) {\n    text = oneVerse ? verses.join(' ') : verses.join('\\n')\n  } else if (includesNumbers) {\n    text = oneVerse ? verses.join(' ') : verses.map((v, i) => numberedVerse(i, v)).join(' ')\n  } else {\n    text = verses.join(' ')\n  }\n\n  const content = `${t.quoteCharsBefore}${text}${t.quoteCharsAfter}`\n  const separator = t.referenceLine === 'new line' ? '\\n' : ' '\n  const referenceFirst = t.referencePosition === 'before'\n\n  return { reference, separator, content, referenceFirst }\n}\n\n/**\n * Format a passage as a string\n *\n * @param template - Format template configuration\n * @param passage - Passage reference\n * @param translationContent - Bible translation content\n * @param bookNames - Array of book names\n * @param translationAbbreviation - Translation abbreviation\n * @returns Formatted string\n */\nexport function formatPassage(\n  template: FormatTemplateData,\n  passage: Passage,\n  translationContent: TranslationContent,\n  bookNames: string[],\n  translationAbbreviation: string\n): string {\n  const result = formatPassageComposable(template, passage, translationContent, bookNames, translationAbbreviation)\n  if (!result) return ''\n\n  const { reference, separator, content, referenceFirst } = result\n\n  // If referenceWithoutContent is true, return only the reference\n  if (template.referenceWithoutContent) {\n    return reference\n  }\n\n  return referenceFirst ? reference + separator + content : content + separator + reference\n}\n\n/**\n * Format a passage reference (without content)\n *\n * @param passage - Passage reference\n * @param bookNames - Array of book names\n * @param separator - Chapter-verse separator character\n * @returns Formatted reference string\n */\nexport function formatReference(\n  passage: Passage,\n  bookNames: string[],\n  separator: string\n): string {\n  const [bookIndex, chapter, start, end] = passage\n  const book = bookNames[bookIndex]\n\n  if (start == null) {\n    return `${book} ${chapter + 1}`\n  } else if (end == null || start === end) {\n    return `${book} ${chapter + 1}${separator}${start + 1}`\n  } else {\n    return `${book} ${chapter + 1}${separator}${start + 1}-${end + 1}`\n  }\n}\n\n/**\n * Format chapter caption\n *\n * @param passage - Passage reference\n * @param bookNames - Array of book names\n * @returns Chapter title string\n */\nexport function formatChapterCaption(passage: Passage | null, bookNames: string[]): string {\n  if (!passage) return ''\n  const [bookIndex, chapter] = passage\n  const book = bookNames[bookIndex]\n  return `${book} ${chapter + 1}`\n}\n\n/**\n * Get verses from a passage\n *\n * @param bible - Translation content\n * @param passage - Passage reference\n * @returns Array of verse strings\n */\nexport function getPassageVerses(bible: TranslationContent, passage: Passage): string[] {\n  const [bi, ci, si, ei] = passage\n  const content = getChapter(bible, bi, ci)\n  if (!content) return []\n\n  const start = si == null ? 1 : si + 1\n  const end = ei == null ? (si == null ? content.length : si + 1) : ei + 1\n  return content.slice(start - 1, end)\n}\n\n/**\n * Get all verses for a chapter containing the passage\n *\n * @param bible - Translation content\n * @param passage - Passage reference\n * @returns Array of all verses in the chapter\n */\nexport function getChapterVerses(bible: TranslationContent, passage: Passage | null): string[] {\n  if (!passage) return []\n  const [book, chapter] = passage\n  const content = getChapter(bible, book, chapter)\n  return content || []\n}\n","/**\n * Template engine for format patterns\n * Framework-agnostic template processing\n */\n\nimport type { Passage, TranslationContent } from '../types'\nimport { getChapter } from '../bible/translation-utils'\n\n/**\n * Pattern configuration for template generation\n */\nexport interface FormatPattern {\n  referencePosition?: 'before' | 'after'\n  referenceNewLine?: 'same line' | 'new line'\n  separatorChar?: string\n  quotes?: boolean\n  verseNewLine?: boolean\n  numbers?: boolean\n}\n\n/**\n * Convert a pattern object to a template string\n *\n * @param pattern - Format pattern configuration\n * @returns Template string with placeholders\n */\nexport function patternToTemplate(pattern: FormatPattern): string {\n  const { referencePosition, referenceNewLine, separatorChar, quotes, verseNewLine, numbers } = pattern\n  const ref = `\\${book} \\${chapter}${separatorChar}\\${start}-\\${end}`\n  let s = `\\${text${numbers ? 'Numbers' : ''}${verseNewLine ? 'NewLines' : ''}}`\n\n  if (quotes) s = `\"${s}\"`\n\n  if (referencePosition === 'before') {\n    s = `${ref}${referenceNewLine === 'new line' ? '\\n' : ' '}${s}`\n  } else {\n    s = `${s}${referenceNewLine === 'new line' ? '\\n' : ' '}${ref}`\n  }\n\n  return s\n}\n\n/**\n * Format a passage using a template string\n * WARNING: This uses eval() - only use with trusted templates\n *\n * @param translationContent - Bible translation content\n * @param passage - Passage reference\n * @param template - Template string with ${} placeholders\n * @param bookNames - Array of book names\n * @param separator - Chapter-verse separator\n * @param translation - Translation name\n * @returns Formatted string\n */\nexport function formatWithTemplate(\n  translationContent: TranslationContent,\n  passage: Passage,\n  template: string,\n  bookNames: string[],\n  separator: string,\n  translation: string\n): string {\n  const [bi, ci, si, ei] = passage\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const book = bookNames[bi]\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const chapter = ci + 1\n  const content = getChapter(translationContent, bi, ci)\n  if (!content) return ''\n\n  const start = si == null ? 1 : si + 1\n  const end = ei == null ? (si == null ? content.length : si + 1) : ei + 1\n  const verses = content.slice(start - 1, end)\n  if (start === end) template = template.replace('-${end}', '')\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const verse = start\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const translationUpperCase = translation ? translation.toUpperCase() : ''\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  let text: string, textNumbers: string, textNewLines: string, textNumbersNewLines: string\n\n  const includesNumbers = template.includes('Numbers')\n  const includesNewLines = template.includes('NewLines')\n  const oneVerse = start === end\n\n  if (includesNumbers && includesNewLines) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    textNumbersNewLines = oneVerse\n      ? verses.join(' ')\n      : '\\n' + verses.map((v, i) => `(${start + i}) ${v}`).join('\\n')\n  } else if (includesNewLines) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    textNewLines = oneVerse ? verses.join(' ') : '\\n' + verses.join('\\n')\n  } else if (includesNumbers) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    textNumbers = oneVerse\n      ? verses.join(' ')\n      : verses.map((v, i) => `(${start + i}) ${v}`).join(' ')\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    text = verses.join(' ')\n  }\n\n  // Note: eval is used for template string evaluation\n  // This should only be used with trusted templates\n  // eslint-disable-next-line no-eval\n  return eval('`' + template + '`')\n}\n"]}